## 704. Binary Search
Given an array of integers ```nums``` which is sorted in ascending order, and an integer ```target```, write a function to search ```target``` in ```nums```. If ```target``` exists, then return its index. Otherwise, return ```-1```.

You must write an algorithm with ```O(log n)``` runtime complexity.

Example 1:
* Input: nums = [-1,0,3,5,9,12], target = 9
* Output: 4
* Explanation: 9 exists in nums and its index is 4

Example 2:
* Input: nums = [-1,0,3,5,9,12], target = 2
* Output: -1
* Explanation: 2 does not exist in nums so return -1


Constraints:

* 1 <= nums.length <= 104
* -104 < nums[i], target < 104
* All the integers in nums are unique.
* nums is sorted in ascending order.

```java
class Solution {
    public int search(int[] nums, int target) {
        // we know that all num are unique and are sorted in ascending order

        // if found return the index
        for (int i = 0 ; i < nums.length; i++)
        {
            if (nums[i] == target)
            {
                return i;
            }
        }
        return -1;
        // else return -1 for not found
        
    }
}
```
* Time Complexity: O(n)
* Space Complexity: O(1)

Optimize 

```Java
class Solution {
    public int search(int[] nums, int target) {
        // we know that all num are unique and are sorted in ascending order

        // if found return the index
        /*
        for (int i = 0 ; i < nums.length; i++)
        {
            if (nums[i] == target)
            {
                return i;
            }
        }
        return -1;
        // else return -1 for not found
        */
        int left = 0 ;
        int right = nums.length - 1;

        while (left <= right)
        {
            int middle = left + ((right - left) / 2);

            if (nums[middle] > target)
            {
                right = middle - 1;
            }
            else if (nums[middle] < target)
            {
                left = middle +1;
            }
            else {
                return middle;
            }
        }
        
        return -1;
    }
}
```
* Time Complexity: O(log n)
* Space Complexity: O(1)
